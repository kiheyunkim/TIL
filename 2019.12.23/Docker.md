# Docker

![docker-logo](image/docker-logo.png)

## Docker?

* 복잡한 리눅스 어플리케이션을 컨테이너로 묶어서 실행할 수 있다.
* 컨테이너(이미지)를 전 세계 사람들과 공유할 수 있다.
* Github와 비슷한 방식의 Docker Hub가 존재한다.



## Why Docker?

* 컨테이너는 가상화 보다 훨씬 가벼운 기술.



### 그럼 가상화(Host 가상화)는?

* Host OS위에서 Guest OS를 올려서 돌리는 행위.
* 가상의 하드웨어를 만들어서 Guest OS를 하여금 그 가상의 하드웨어를 진짜 하드웨어 인것 처럼 인식시키고 가상의 하드웨어를 통해 실제 하드웨어로 접근한다.(**하드웨어 가상화**)

* 기술 발전에 따라 컴퓨터 성능이 급격히 좋아지면서 PC에서도 흔히 사용한다.(ex: 맥에서 인터넷 뱅킹을 위한 부트캠프로 윈도 실행)



## 기존의 서버 모델

* 컴퓨터 한대로 모든 것을 감당하기에는 좋지 않은 성능이었다.
* 이를 해결하기 위해 서버 자체를 분산하여 여러 컴퓨터에 분산시켰다.



## 기술 발전에 따른 서버

* 기술 발전에 따라서 컴퓨터가 좋아지며 서버가 노는 시간이 많아짐.
* 이를 해결하기 위해서 가상머신을 여러 개를 띄워서 일을 더 시킨다.
* 또한 IT기술의 보편화에 따라 서버 자체도 많아짐-> "서버 자체를 가상 머신에 집어 넣어서 돌린다!"
  * 가상 머신에 각종 프로그램 DB등을 설치하여 애플리케이션이나 웹 사이트를 실행한다.
  * 미리 구축한 가상 머신 이미지를 여러 서버에 복사하여 실행하면 이미지 하나로 서버를 계속 만들어낼 수 있음.
  * 이를 돈을 받고 빌려주는 서비스를 **클라우드 서비스** 라고 한다.



## 가상 머신의 문제?

컴퓨터를 통째로 만들어내다 보면 손실이 발생함

예)

* VMWARE의 초기 HDD 크기 설정 - 정확한 수요 계산 불가
* 그외의 여러 요소들도 경우에 따라 변할 수 있다.



## 그래서 등장한 반가상화

윈도우와 AMD는 CPU안에 가상화 기능을 넣기 시작하였다. 그이름 [Hypervisor](https://www.alibabacloud.com/ko/knowledge/what-is-hypervisor)

* HOST OS와 커널의 일부를 공유하기 때문에 조금 더 빠르다.

* 중간레이어가 줄었기에 조금 더 빠르다.

* **계층구조**
  >
  > ​     APP    |     APP    |       APP   |     APP     |      APP     |     APP
  >
  > -----
  >
  > Client OS|Client OS|Client OS|Client OS  |Client OS | Client OS
  >
  > -----
  >
  > HyperVisor
  >
  > -----
  >
  > Host OS
  >
  > -----
  >
  > H/W

하지만 이 또한도 단점이 있었다.



## 반가상화의 단점

* 가상 머신은 완전한 컴퓨터 그자체이기 때문에 항상 Guest OS를 설치해야한다.
* Host OS와 공통부분을 가졌으나 **각자의 OS를 가져야한다.**(중복 공간 낭비)

* OS가 이미지 않에 포함되어 있기 때문에 **이미지 용량이 커진다**.
* 이미지 용량이 커진만큼 네트워크로 가상화 **이미지를 주고 받는건 부담** 스럽다.
* 즉, 오픈소스 가상화 소프트웨어는 OS가상화에만 주력했지 **배포와 관리 기능이 부족**했다.
* 이런 것을 해결하고자 등장한 것이 리눅스 컨테이너



## Linux Container

컨테이너 안에 가상공간을 만들지만, 실행 파일은 호스트에서 직접실행하는 기술.

리눅스 커널의 cgroups와 namespaces가 제공하는 기술.

* 도커는 리눅스 컨테이너를 사용한다
* 초기에는 LXC를 기반으로 구현되었다.
* 버전 0,9 부터는 LXC대신 libcontainer를 개발하여 사용



## 도커의 특징

* 도커는 GuestOS를 설치하지 않는다. -> 기존의 Hypervisor위치에 도커 엔진이 들어간다.

* 이미지에 서버 운영을 위한 프로그램과 라이브러리만 격리해서 설치한다.-> 이미지 용량이 크게 줄어든다.

* 호스트와 OS자원(시스템 콜)을 공유한다.

* OS위에서 컨테이너 관리 툴(Docker Engine)을 통해서 논리적으로 컨테이너를 나누어 사용하고 OS가 있는것 처럼 작동한다. (OS 가상화)
  
* **계층 구조**

  >어플리케이션 A  | 어플리케이션 B
  >
  >--------------------------------------------
  >
  >실행파일  /  LIB  | 실행파일  /  LIB  
  >
  >-------
  >
  >도커 엔진
  >
  >----
  >
  >호스트 OS
  >
  >-----
  >
  >서버(H/W) 등

  

* 도커는 하드웨어 가상화 계층이 없다.

  * 메모리 접근, 파일 시스템, 네트워크 전송 속도가 가상 머신에 비해 월등히 빠르다.

  * 호스트와 도커 컨테이너 사이의 성능차이가 크지 않다(오차 범위안)

  * 가상머신은 실제 하드웨어를 HyperVisor를 통해서 접근했지만 도커는 그렇지 않기 때문이다.

    

* 도커는 이미지 생성과 배포에 특화

  * 이미지 버전 관리도 제공하고 중앙 저장소에 이미지를 올리고 받을 수 있음(Push/Pull)
  * Github와 비슷한 형태로 도커 이미지를 공유하는 Docker HUB를 제공한다. Pulbic 업로드시 무료 (Private 저장공간은 유료로 제공함)
  * 다양한 API를 제공하여 원하는 만큼 자동화 기능 개발과 서버 운영에 매우 유용하다.
  * CI/CD : 지속적인 통합/ 지속적인 배포
    * 대표적인 CI/CD도구가 **허드슨**이었고 최근의 업데이트로 바뀐 이름은 **젠킨스(정확히는 CI)**



## 이미지와 컨테이너의 차이

#### **이미지**: 서비스 운영에 필요한 서버 프로그램, 소스코드, 컴파일된 실행파일을 묶은 형태

* 자바의 클래스에 해당함



#### **컨테이너**: 이미지를 실행한 상태

* 자바의 클래스 인스턴스에 해당함

* 이미지로 여러개의 컨테이너를 만들 수 있음(기존 가상머신에서는 각 머신에 해당하는 디렉토리 각각에 이미지를 복사해 넣고 실행했어야했음)

  

#### 두 가지의 특징

* **운영체제에 비유하자면 이미지는 실행파일 컨테이너는 프로세스**

* ##### 유니온 파일 시스템 형식으로 이미지의 변경을 처리한다.

  * ##### aufs,btrfs등

  * ##### 베이스 이미지에서 바뀐 부분만 이미로 생성한다.

  * 컨테이너로 실행할 떄는 베이스 이미지와 바뀐 부분을 합쳐서 실행(Union) 해서 쪼갠다. 이 방법을 통해서 전체 용량은 줄어든다.

  * Docker Hub 및 개인 저장소에서 이미지를 공유할 때 **바뀐 부분만 주고 받음**

  * 각 이미지는 **의존 관계** 형성



## 서비스 운영 환경과 도커

물리 서버를 직접 운영하는데에서 가상화가 발전하면서 클라우드 환경으로 변화함에 따라서 가상서버를 임대하여 사용한 만큼 요금을 지불하는 시스템이 갖춰졌다. 클릭 몇 번 만으로 가상 서버를 생성, 추가, 삭제가 쉬워졌다. 그러나 세팅은 힘들어짐



#### 그러면 서버 세팅과 배포는 어떻게?????

그래서 나온것이 **Immutable Infrastructure**라는 패러다임이 등장 -> OS와 서비스 운영 환경을 분리한다.



#### Immutable Infrastructure

* 한번 설정한 운영 환경은 변하지 않는다.(Immutable)의 개념, 환경은그냥 두고 변경 하지 않아된다. -> 모듈화가 되어 있으므로 모듈만 갈아치우면된다.

* 서비스 운영 환경을 이미지로 생성한 뒤 서버에 배포하여 실행한다.
* 서비스가 업데이트 되면 운영 환경자체를 변경하지 않고, 이미지를 새로 생성하여 배포한다.
* 클라우드 플랫폼에서 서버를 쓰고 버리는 것과 같이 Immutable Infrastructure도 한번 쓰고 버림.
* 예전에는 한번 맞춰두면 그것들을 유지하는데 힘썼음. ----> 지금은 교체해버린다.
